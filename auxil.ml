(* Some auxiliary functions *)

(* TODO: Name management needs a second thought *)

open Verif_condition.VerifCondition;;


(* Set and bag manipulating functions. Bag: no multiple occurrences, order relevant  *)
(* let list_inters xs ys = List.filter (fun x -> List.mem x ys) xs
*)

(* List [n ... 1] *)
(* let rec n_list n = if n = 0 then [] else n :: n_list (n - 1)

let bag_insert_front x xs = if List.mem x xs then xs else x::xs
let bag_insert_end x xs = if List.mem x xs then xs else xs@[x]
*)

(* set datatype generated by Isabelle *)
(* let list_of_set = function
  | Coset xs -> failwith "list_of_set with Coset"
  | Set xs -> xs
*)

(* Name management *)
let free_var_names xs = 
  let frees = List.filter (function Free v-> true | Bound n -> false) xs in
  List.map (function Free v-> v | Bound n -> failwith "impossible") frees
;;


(* generate a new variable name from a suggestion and a set of already used names *)
(* let rec new_var_string sugg used_names = 
  if List.mem sugg used_names
  then new_var_string (sugg ^ "_") used_names
  else sugg
*)
let new_var_string sugg used_names = fresh_string_literal used_names sugg

(* let rec gen_new_vars n x vrs = 
  let sugg = List.map (fun i -> x ^ "_" ^ (string_of_int i)) (n_list n) in 
  if list_inters sugg vrs = []
  then sugg
  else gen_new_vars n (x ^ "_g") vrs

*)




