(* Improved ALCQ prover.
   Constructors currently not treated: AllC, SomeC (not generated by parser)

   THIS VERSION: Introduced Big_int, but in an incomplete manner. All explicit or
   implicit comparisons of Big_int or constructors containing them have to be
   done with specific comparison functions, not with = or < etc.  

*)

open Verif_condition.VerifCondition ;;
open Lang ;;
open Auxil;;


type ('nr, 'nc, 'ni) rule_rep =
  Clash_rep
| AndRule_rep of ('nr, 'nc, 'ni) form
| OrRule_rep of ('nr, 'nc, 'ni) form
| ConjRule_rep of ('nr, 'nc, 'ni) form
| DisjRule_rep of ('nr, 'nc, 'ni) form
| Todo_rep

type ('a, 'b) proof_result = 
  TablUnsatisf of 'a
| TablSatisf of 'b

type ('nr, 'nc, 'ni) trace = 
  Trace of ('nr, 'nc, 'ni) rule_rep * ('nr, 'nc, 'ni) trace list

type ('nr, 'nc, 'ni) trace_constr = 
  CTrace of ('nr, 'nc, 'ni) trace       (* complete trace *)
| ITrace of ('nr, 'nc, 'ni) trace list * int * ('nr, 'nc, 'ni) rule_rep (* incomplete trace *)


(* new_form: may contain any formula except for negations
 *)
type ('nr, 'nc, 'ni) new_form = ('nr, 'nc, 'ni) form list

(* active_linear_form:
   FactFm(Inst(x, BinopC(Conj, c1, c2)))
   FactFm(Inst(x, NumRestrC(Ge, n, r, c)))
   FactFm(Inst(x, SubstC(c, sb)))
   FactFm(Inst(x, SomeC(r, c)))
   FactFm(Inst(x, AllC(r, c)))
   FactFm(Eq(true, x, y)) for x /= y
   BinopFm (Conj, f1, f2)
   SubstFm (f, sb)
  *)

type ('nr, 'nc, 'ni) active_linear_form = ('nr, 'nc, 'ni) form list

(* active_splitting_form:
   FactFm(Inst(x, BinopC(Disj, c1, c2)))
   BinopFm (Disj, f1, f2)
*)
type ('nr, 'nc, 'ni) active_splitting_form = ('nr, 'nc, 'ni) form list

(* active_permanent_form: permanently active formula
   FactFm(Inst(x, NumRestrC(Lt, n, r, c)))      
*)

type ('nr, 'nc, 'ni) active_permanent_form = ('nr, 'nc, 'ni) form list

(* inactive_composite:
   FactFm(Inst(x, Top))
   FactFm(Eq(true, x, x))
   ConstFm true
   FactFm(Inst(x, BinopC(Conj, c1, c2)))
   FactFm(Inst(x, NumRestrC(Ge, n, r, c)))
   FactFm(Inst(x, SubstC(c, sb)))
   FactFm(Inst(x, BinopC(Disj, c1, c2)))
   BinopFm (Conj, f1, f2)
   BinopFm (Disj, f1, f2)
   SubstFm (f, sb)
*)
type ('nr, 'nc, 'ni) inactive_composite = ('nr, 'nc, 'ni) form list

(* inactive_atomc:
   FactFm(Inst(x, AtomC(sign, a)))
*)
type ('nr, 'nc, 'ni) inactive_atomc = ('nr, 'nc, 'ni) form list

(* inactive_atomr:
   FactFm(AtomR(sign, r, x, y))
*)
type ('nr, 'nc, 'ni) inactive_atomr = ('nr, 'nc, 'ni) form list

(* inactive_equivs:
   FactFm(Eq(false, x, y)) for x /= y
 *)
type ('nr, 'nc, 'ni) inactive_equivs = ('nr, 'nc, 'ni) form list

(* inactive_clash:
   FactFm(Inst(x, Bottom))
   FactFm(Eq(false, x, x))
   ConstFm false
 *)
type ('nr, 'nc, 'ni) inactive_clash = ('nr, 'nc, 'ni) form list

type ('nr, 'nc, 'ni) inactive_form = Inactive_form of 
    ('nr, 'nc, 'ni) inactive_composite *
      ('nr, 'nc, 'ni) inactive_atomc *
      ('nr, 'nc, 'ni) inactive_atomr *
      ('nr, 'nc, 'ni) inactive_equivs *
      ('nr, 'nc, 'ni) inactive_clash

type ('nr, 'nc, 'ni) branch = Branch of 
    ('nr, 'nc, 'ni) new_form * 
      ('nr, 'nc, 'ni) active_linear_form * 
      ('nr, 'nc, 'ni) active_splitting_form * 
      ('nr, 'nc, 'ni) active_permanent_form * 
      ('nr, 'nc, 'ni) inactive_form

type ('nr, 'nc, 'ni) proofstate = ('nr, 'nc, 'ni) branch list

type ('nr, 'nc, 'ni) apply_result = 
  AppRes of int * ('nr, 'nc, 'ni) rule_rep option * ('nr, 'nc, 'ni) proofstate


    (* ----------------------------------------------------------------------  *)
    (* Auxiliary functions  *)


let set_of_pairs xs = 
  List.concat 
    (List.map (fun x1 -> 
      List.concat (List.map (fun x2 -> if x1 < x2 then [(x1, x2)] else []) xs)) xs)

let make_mutually_distinct nvrs = 
  List.map (fun (x, y) -> FactFm (Eq(false, x, y))) (set_of_pairs nvrs)

let make_outgoing_r_c_from x r c nvrs =
  (List.map (fun y -> FactFm (AtomR(true, r, x, y))) nvrs) @
  (List.map (fun y -> FactFm (Inst(y, c))) nvrs)

let rec powerset = function
  | [] -> [[]]
  | x::xs -> 
    let p = powerset xs in
    (List.map (fun ys -> x::ys) p) @ p

(* all the subsets of xs having size n *)
let n_subsets n xs = List.filter (fun ys -> List.length ys = n) (powerset xs)


    (* ----------------------------------------------------------------------  *)
    (* Proof state management *)

let add_new_form f (Branch(n, alf, asf, ap, ia)) =
  (Branch(f::n, alf, asf, ap, ia))

let add_new_forms fs (Branch(n, alf, asf, ap, ia)) =
  (Branch(fs@n, alf, asf, ap, ia))

let add_active_linear f (Branch(n, alf, asf, ap, ia)) =
  (Branch(n, bag_insert_front f alf, asf, ap, ia))

let add_active_splitting f (Branch(n, alf, asf, ap, ia)) =
  (Branch(n, alf, bag_insert_front f asf, ap, ia))

(* the new formula is added at the end to allow for a fair rule application *)
let add_active_permanent f (Branch(n, alf, asf, ap, ia)) =
  (Branch(n, alf, asf, bag_insert_end f ap, ia))

let add_inactive_composite f (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) =
  (Branch(n, alf, asf, ap, Inactive_form(bag_insert_front f ico, iac, iar, ie, icl)))

let add_inactive_atomc f (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) =
  (Branch(n, alf, asf, ap, Inactive_form(ico, bag_insert_front f iac, iar, ie, icl)))

let add_inactive_atomr f (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) =
  (Branch(n, alf, asf, ap, Inactive_form(ico, iac, bag_insert_front f iar, ie, icl)))

let add_inactive_equivs f (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) =
  (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, bag_insert_front f ie, icl)))

let add_inactive_clash f (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) =
  (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, bag_insert_front f icl)))

(* some inequalities may have become clashs after equality substitutions. *)
let reactivate_equivs (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) =
  (Branch(n@ie, alf, asf, ap, Inactive_form(ico, iac, iar, [], icl)))


    (* ----------------------------------------------------------------------  *)
    (* Classification of formulas *)


(* TODO: check negation normal form *)
let classify_concept br = function
  | FactFm(Inst(x, Bottom)) as f -> add_inactive_clash f br
  | FactFm(Inst(x, Top)) as f -> add_inactive_composite f br
  | FactFm(Inst(x, AtomC(sign, a))) as f -> add_inactive_atomc f br
  | FactFm(Inst(x, NegC(c))) ->  failwith "negation in classify_concept"
  | FactFm(Inst(x, BinopC(Conj, c1, c2))) as f -> add_active_linear f br
  | FactFm(Inst(x, BinopC(Disj, c1, c2))) as f -> add_active_splitting f br
  | FactFm(Inst(x, NumRestrC(Lt, n, r, c))) as f -> add_active_permanent f br
  | FactFm(Inst(x, NumRestrC(Ge, n, r, c))) as f -> add_active_linear f br
  | FactFm(Inst(x, SubstC(c, sb))) as f -> add_active_linear f br
  | FactFm(Inst(x, SomeC(r, c))) as f -> add_active_linear f br
  | FactFm(Inst(x, AllC(r, c))) as f -> add_active_linear f br
  | _ -> failwith "match failure classify_concept"


let classify_fact br = function
  | FactFm(Inst(x, c)) as f -> classify_concept br f
  | FactFm(AtomR(sign, r, x, y)) as f -> add_inactive_atomr f br
  | FactFm(Eq(true, x, y)) as f -> 
    if x = y 
    then add_inactive_composite f br
    else add_active_linear f br
  | FactFm(Eq(false, x, y)) as f -> 
    if x = y 
    then add_inactive_clash f br
    else add_inactive_equivs f br
  | _ -> failwith "match failure classify_fact"


let classify_form br = function 
  | (ConstFm false) as f -> add_inactive_clash f br
  | (ConstFm true) as f -> add_inactive_composite f br
  | (FactFm fct) as f -> classify_fact br f
  | NegFm f -> failwith "negation in classify_form"
  | BinopFm (Conj, f1, f2) as f -> add_active_linear f br
  | BinopFm (Disj, f1, f2) as f -> add_active_splitting f br
  | SubstFm (f1, sb) as f -> add_active_linear f br

let classify_new = function
  | (Branch([], alf, asf, ap, ia)) as br -> br
  | (Branch(nf :: nfs, alf, asf, ap, ia)) -> 
    classify_form (Branch(nfs, alf, asf, ap, ia)) nf


    (* ----------------------------------------------------------------------  *)
    (* Number restrictions *)

let outgoing_rel_from (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) x r = 
  remdups {equal = (=)}
    (List.fold_left
       (fun res f ->
         match f with
         | FactFm (AtomR(sign, r', x', y)) -> if sign && x = x' && r = r' then y::res else res
         | _ -> res)
       []
       iar)

let having_class (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) x c =
  List.exists
    (function
    | FactFm (Inst(x', c')) -> x = x' && c = c' 
    | _ -> false)
    (alf @ asf @ ico @ iac)

let unequal_in (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) x1 x2 =
    (List.mem (FactFm(Eq(false, x1, x2))) ie) || (List.mem (FactFm(Eq(false, x2, x1))) ie)

let mutually_distinct br xs = 
  List.for_all (fun x1 -> List.for_all (fun x2 -> x1 = x2 || unequal_in br x1 x2) xs) xs

let exist_outgoing_r_c_distincts_from br x n r c = 
  let ys_outgoing = outgoing_rel_from br x r in
  let ys_c = List.filter (fun y -> having_class br y c) ys_outgoing in
  let ns = n_subsets n ys_c in 
  List.exists (mutually_distinct br) ns

let numrestrc_ge_applicable br x n r c =
  not (exist_outgoing_r_c_distincts_from br x n r c)

let numrestrc_lt_applicable_vars br x n r c = 
  let ys_outgoing = remdups {equal = (=)} (outgoing_rel_from br x r) in
  let ys_c = List.filter (fun y -> having_class br y c) ys_outgoing in
  if List.length ys_c < n
  then []
  else 
    let pys = set_of_pairs ys_c in
    List.filter (fun (x1, x2) -> not (unequal_in br x1 x2)) pys

let numrestrc_lt_applicable br x n r c = 
  not (numrestrc_lt_applicable_vars br x n r c = [])

let choose_applicable_vars br x r c = 
  let ys_outgoing = remdups {equal = (=)} (outgoing_rel_from br x r) in
  let ys_c = List.filter (fun y -> having_class br y c) ys_outgoing in
  let not_c = (neg_norm_concept false c) in
  let ys_not_c = List.filter (fun y -> having_class br y not_c) ys_outgoing in
  let ys_undet = List.filter (fun y -> not (List.mem y ys_c) && not (List.mem y ys_not_c)) ys_outgoing in
  let ys_contrad = list_inters ys_c ys_not_c in
  (ys_undet, ys_contrad)

let choose_applicable br x r c = not (fst (choose_applicable_vars br x r c) = [])

    (* ----------------------------------------------------------------------  *)
    (* Rule application *)


(* TODO: make more efficient, by not taking the union of all formulas *)
let all_forms (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) =
  n @ alf @ asf @ ap @ ico @ iac @ iar @ ie @ icl


let and_applicable br x c1 c2 = 
  let fs = all_forms br in 
  not (List.mem (FactFm(Inst(x,c1))) fs && List.mem (FactFm(Inst(x,c2))) fs)

let or_applicable br x c1 c2 = 
  let fs = all_forms br in 
  not (List.mem (FactFm(Inst(x,c1))) fs) && not (List.mem (FactFm(Inst(x,c2))) fs)

let conj_applicable br f1 f2 = 
  let fs = all_forms br in not (List.mem f1 fs && List.mem f2 fs)

let disj_applicable br f1 f2 = 
  let fs = all_forms br in not (List.mem f1 fs) && not (List.mem f2 fs)

let subst_applicable br fp = 
  let fs = all_forms br in not (List.mem fp fs)

let inactive_form_apply f (Inactive_form(ico, iac, iar, ie, icl)) =
  Inactive_form(f ico, f iac, f iar, f ie, f icl)

let branch_apply f (Branch(n, alf, asf, ap, ia)) = 
  (Branch(f n, f alf, f asf, f ap, inactive_form_apply f ia))

let propagate_equality x y xs = 
  let eqs = {equal = (=)} in 
  remdups eqs (List.map (fun frm -> push_isubst_form eqs frm [(x, y)]) xs)

let fv_branch br = 
    let eqs = {equal = (=)} in 
    let fs = all_forms br in 
    List.fold_left (fun res vs -> (fv_form_list eqs vs) @ res) [] fs

let numrestrc_ge_generated (br: ('nr, 'nc, string) branch) x n r c = 
  let vrs = fv_branch br in
  let nvrs = gen_new_vars n x vrs in
  make_mutually_distinct nvrs @ make_outgoing_r_c_from x r c nvrs

let apply_linear br = function
  | FactFm(Inst(x, BinopC(Conj, c1, c2))) as f -> 
    if and_applicable br x c1 c2
    then AppRes(1, Some (AndRule_rep f),
                [add_new_forms [FactFm (Inst(x, c2)); FactFm (Inst(x, c1))]
                    (add_inactive_composite f br)])
    else AppRes(0, None, [add_inactive_composite f br])
(*
  | FactFm(Inst(x, NumRestrC(Ge, Nat 0, r, c))) as f -> 
    AppRes(0, None, [add_inactive_composite f br])
*)
  | FactFm(Inst(x, NumRestrC(Ge, n, r, c))) as f -> 
    if Big_int.eq_big_int (integer_of_nat n) Big_int.zero_big_int
    then AppRes(0, None, [add_inactive_composite f br])
    else if numrestrc_ge_applicable br x (Big_int.int_of_big_int (integer_of_nat n)) r c
    then AppRes(1, Some Todo_rep, 
                [add_new_forms 
                    (numrestrc_ge_generated br x (Big_int.int_of_big_int (integer_of_nat n)) r c)
                    (add_inactive_composite f br)])
       else AppRes(0, None, [add_inactive_composite f br])
  | FactFm(Inst(x, SubstC(c, sb))) as f ->
    let eqs = {equal = (=)} in 
    let fp = (neg_norm_form true (push_subst_form eqs eqs eqs f [])) in
    if subst_applicable br fp
    then AppRes(1, Some Todo_rep, [add_new_form fp (add_inactive_composite f br)])
    else AppRes(0, None, [add_inactive_composite f br])
  | FactFm(Eq(true, x, y)) as f -> 
    AppRes(1, Some Todo_rep, 
           [reactivate_equivs
               (branch_apply (propagate_equality x y) (add_inactive_composite f br))])
  | BinopFm (Conj, f1, f2) as f ->
    if conj_applicable br f1 f2
    then AppRes(1, Some (ConjRule_rep f), 
                [add_new_forms [f2; f1] (add_inactive_composite f br)])
    else AppRes(0, None, [add_inactive_composite f br])
  | SubstFm (f1, sb) as f -> 
    let eqs = {equal = (=)} in 
    let fp = (neg_norm_form true (push_subst_form eqs eqs eqs f1 [sb])) in
    if subst_applicable br fp
    then AppRes(1, Some Todo_rep, [add_new_form fp (add_inactive_composite f br)])
    else AppRes(0, None, [add_inactive_composite f br])
  | f  -> failwith ("match failure apply_linear: " ^ (print_form f))


(* TODO
  | FactFm(Inst(x, SomeC(r, c))) ->
  | FactFm(Inst(x, AllC(r, c))) ->
*)

let apply_splitting br = function
  | FactFm(Inst(x, BinopC(Disj, c1, c2))) as f -> 
    if or_applicable br x c1 c2
    then AppRes(2, Some (OrRule_rep f), 
                [add_new_form (FactFm (Inst(x, c1))) (add_inactive_composite f br);
                 add_new_form (FactFm (Inst(x, c2))) (add_inactive_composite f br)])
    else AppRes(0, None, [add_inactive_composite f br])
  | FactFm(Inst(x, SubstC(c, sb))) as f -> 
    let eqs = {equal = (=)} in 
    let fp = (neg_norm_form true (push_subst_form eqs eqs eqs f [])) in
    if subst_applicable br fp
    then AppRes(1, Some Todo_rep, [add_new_form fp (add_inactive_composite f br)])
    else AppRes(0, None, [add_inactive_composite f br])
  | BinopFm (Disj, f1, f2) as f ->
    if disj_applicable br f1 f2
    then AppRes(2, Some (DisjRule_rep f), 
                [add_new_form f1 (add_inactive_composite f br); 
                 add_new_form f2 (add_inactive_composite f br)])
    else AppRes(0, None, [add_inactive_composite f br])
  | f  -> failwith ("match failure apply_splitting: " ^ (print_form f))

let apply_permanent br = function
  | FactFm(Inst(x, NumRestrC(Lt, n, r, c))) as f -> 
    (match numrestrc_lt_applicable_vars br x (Big_int.int_of_big_int (integer_of_nat n)) r c with
    | [] -> 
      (match choose_applicable_vars br x r c with
      | ([], []) -> 
        (* neither numrestrc rule nor choose rule applicable to this f *)
        AppRes(0, None, [(add_active_permanent f br)])
      | ([], _) -> 
        (* there is y with y : C and y : - C, for composite C *)
        (* TODO: needs some further thought. Add another clash rule for composite concepts? *)
        AppRes(1, Some Todo_rep, [(add_inactive_clash (ConstFm false) br)])
      | (y::ys, _) -> 
        (* there is a choose candidate y *)
        AppRes(2, Some Todo_rep, 
               [add_new_form (FactFm(Inst(y,c))) (add_active_permanent f br);
                add_new_form (FactFm(Inst(y,neg_norm_concept false c))) (add_active_permanent f br)])
      )
    | varpairs -> 
      AppRes(List.length varpairs, Some Todo_rep, 
             List.map
               (fun (x, y) -> add_new_form (FactFm (Eq(true, x, y))) (add_active_permanent f br))
               varpairs)
    )
  | f  -> failwith ("match failure apply_permanent: " ^ (print_form f))

    (* ----------------------------------------------------------------------  *)
    (* Clashes *)


let is_bottom = function
  | FactFm (Inst(x, Bottom)) -> true
  | _ -> false

let is_neg_concept f = function
  | FactFm (Inst(x, AtomC(sign, a))) -> (f = (FactFm (Inst(x, AtomC(not sign, a)))))
  | _ -> false

let is_neg_role f = function
  | FactFm (AtomR(sign, r, x, y)) -> (f = (FactFm (AtomR(not sign, r, x, y))))
  | _ -> false

let is_ineq_inst = function
  | FactFm (Eq(false, x, y)) -> (x = y)
  | _  -> false

let is_falsefm = function
  | ConstFm false -> true
  | _ -> false


(* the following three are subsumed by nonempty_clashset *)
let contains_bottom (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) = 
  List.exists is_bottom icl

let contains_falsefm (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) = 
  List.exists is_falsefm icl

let contains_contr_eq (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) = 
  List.exists is_ineq_inst icl

let nonempty_clashset (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) =
  not (icl = [])

let contains_contr_concept (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) = 
  List.exists (fun f -> List.exists (is_neg_concept f) iac) iac

let contains_contr_role (Branch(n, alf, asf, ap, Inactive_form(ico, iac, iar, ie, icl))) = 
  List.exists (fun f -> List.exists (is_neg_role f) iar) iar

let contains_numrestr_clash ((Branch(n, alf, asf, ap, ia)) as br) =
  List.exists 
    (function 
(*
    | FactFm(Inst(x, NumRestrC(Lt, Nat 0, r, c))) -> true
*)
    | FactFm(Inst(x, NumRestrC(Lt, n, r, c))) -> 
      if Big_int.eq_big_int (integer_of_nat n) Big_int.zero_big_int
      then true
      else exist_outgoing_r_c_distincts_from br x (Big_int.int_of_big_int (integer_of_nat n)) r c
    | _ -> false
    )
    ap

(* don't try looking for a clash as long as there are new formulas *)
let contains_clash = function
  | (Branch([], _, _, _, _)) as br -> 
    (nonempty_clashset br ||
     contains_contr_concept br ||
     contains_contr_role br ||
     contains_contr_eq br ||
     contains_falsefm br ||
     contains_numrestr_clash br)
  | _ -> false


    (* ----------------------------------------------------------------------  *)
    (* Search *)

let is_applicable_permanent br = function
  | FactFm(Inst(x, NumRestrC(Lt, n, r, c))) ->
    choose_applicable br x r c || 
      numrestrc_lt_applicable br x (Big_int.int_of_big_int (integer_of_nat n)) r c
  | _ -> false

let is_inactive = function
  | (Branch([], [], [], ap, ia)) as br -> 
    List.for_all (fun f -> (not (is_applicable_permanent br f))) ap
  | _ -> false


(* TODO: reconsider termination problem described in BS p.11
--> problem does not seem to occur here, since exist-rules are applied only once *)

(* Former proof search
let apply_rules = function
  | Branch([], [], [], [], _) -> 
    failwith "apply_rules should have active branch"
  | Branch([], [], [], apf::apfs, ia) -> 
    List.map classify_new (apply_permanent (Branch([], [], [], apfs, ia)) apf)
  | Branch([], [], asf::asfs, ap, ia) -> 
    List.map classify_new (apply_splitting (Branch([], [], asfs, ap, ia)) asf)
  | Branch([], alf::alfs, asf, ap, ia) -> 
    [classify_new (apply_linear (Branch([], alfs, asf, ap, ia)) alf)]
  | br -> [classify_new br]

let rec search = function
  | [] ->  []
  | br :: brs -> 
    if contains_clash br
    then search brs
    else if is_inactive br 
    then [br]
    else search ((apply_rules br) @ brs)
*)


let map_classify_branches = function
  | AppRes(n, rr_opt, brs) -> AppRes(n, rr_opt, List.map classify_new brs)

let apply_rules_pt = function
  | Branch([], [], [], [], _) -> 
    failwith "apply_rules_pt should have active branch"
  | Branch([], [], [], apf::apfs, ia) -> 
    map_classify_branches (apply_permanent (Branch([], [], [], apfs, ia)) apf)
  | Branch([], [], asf::asfs, ap, ia) -> 
    map_classify_branches (apply_splitting (Branch([], [], asfs, ap, ia)) asf)
  | Branch([], alf::alfs, asf, ap, ia) -> 
    map_classify_branches (apply_linear (Branch([], alfs, asf, ap, ia)) alf)
  | br -> AppRes(0, None, [classify_new br])

(* collects complete failed subproofs and constructs a proof trace out of them  *)
let rec failed_subproof current = function
  | [] -> [CTrace current]
  | ITrace(subtrs, n, rr) :: traces -> 
    if List.length subtrs + 1 = n 
    then failed_subproof (Trace(rr, List.rev (current::subtrs))) traces
    else ITrace(current::subtrs, n, rr)::traces
  | CTrace tr :: traces -> failwith "failed_subproof: CTrace"

let rec search_pt = function
  | ([CTrace tr], []) ->  TablUnsatisf tr
  | (traces, br :: brs) -> 
    if contains_clash br
    then search_pt (failed_subproof (Trace(Clash_rep, [])) traces, brs)
    else if is_inactive br 
    then TablSatisf br
    else 
      (match apply_rules_pt br with
      | AppRes(_, None, new_brs) -> search_pt (traces, new_brs @ brs)
      | AppRes(n, Some rr, new_brs) -> search_pt (ITrace([], n, rr)::traces, new_brs @ brs))
  | (_, []) -> failwith "search_pt: wrongly constructed trace"

(*
let prove fs = search [Branch(fs, [], [], [], Inactive_form([], [], [], [], []))]
*)

let prove_pt fs = search_pt ([], [Branch(fs, [], [], [], Inactive_form([], [], [], [], []))])

(* Tests *)


(* for prove_pt:
# prove_pt [FactFm (Inst("x", BinopC(Conj, AtomC(true, "a"), AtomC(true, "b"))))] ;;
# prove_pt [FactFm (Inst("x", BinopC(Conj, AtomC(true, "a"), AtomC(false, "a"))))] ;;

 *)

(*
for contains_numrestr_clash:

let br1 = 
  Branch ([],
   [FactFm (Inst ("x", NumRestrC (Lt, Nat (Big_int.big_int_of_int 3), "r", AtomC (true, "c"))))],
   [], [],
   Inactive_form ([],
    [FactFm (Inst ("y1", AtomC (true, "c")));
     FactFm (Inst ("y2", AtomC (true, "c")));
     FactFm (Inst ("y3", AtomC (true, "c")))],
    [FactFm (AtomR (true, "r", "x", "y1"));
     FactFm (AtomR (true, "r", "x", "y2"));
     FactFm (AtomR (true, "r", "x", "y3"))],
    [FactFm (Eq (false, "y1", "y2")); FactFm (Eq (false, "y3", "y2"));
     FactFm (Eq (false, "y3", "y1"))],
    []))
# contains_numrestr_clash br1 ;;

prove_pt [FactFm (Inst ("e", NumRestrC (Lt, Nat (Big_int.big_int_of_int 1), "r", SubstC(AtomC (true, "A"),RSubst("r", RDiff, ("e", "n")))))); FactFm (Inst ("e1", AtomC (true, "A"))); FactFm (AtomR(true, "r", "e", "e1"))] ;;


 *)
